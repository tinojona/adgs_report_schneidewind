---
title: "9 Regression and Classification - Report Exerise"
author: "Tino Schneidewind"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

## objective:

stepwise forward regression is to be performed for the task of modelling GPP_NT_VUT_REF as a function of predictors available in the dataset of half-hourly ecosystem fluxes.

1. An evaluation of all bivariate models (single predictor), implementing just steps 1-3 of the algorithm described in Section 9.3.3.1.

2. An implementation of stepwise forward regression, and a visualisation and discussion of its results.

I keep siteid as a categorical predictor
I will invetigate linear, quadratic, and exponential models
```{r readdata, message=FALSE, warning=FALSE}
# libraries
library(ggplot2) # plotting
library(dplyr)   # adjusting data
library(tidyverse) # cleaning
library(rlang)    # formula
library(purrr)    # functions
library(gridExtra) # plotting
library(knitr)  # tables
library(kableExtra) # nice tables
# rm(list = ls())


# data 
half_hourly_fluxes <- readr::read_csv("../data/df_for_stepwise_regression.csv")|>
  dplyr::select(-starts_with("TIMESTAMP")) |>
  mutate(siteid = as.factor(siteid)) |>
  tidyr::drop_na()

```

objective 1:

bivariate models

```{r exerc1, warning=FALSE, message=FALSE, fig.height= 22, fig.width= 10, fig.align='center'}
# variables for bivariate analysis
vars <- colnames(half_hourly_fluxes[c(1:14,16)])

# function to extract model performance
fit_model <- function(var) {
  formula_mod <- as.formula(paste0("GPP_NT_VUT_REF ~ ", var))
  mod <- lm(formula = formula_mod, data = half_hourly_fluxes)
  
  tibble(
    predictor = var,
    R2 = summary(mod)$r.squared,
    AIC = extractAIC(mod)[2]
  )
}

# apply function
results_1 <- map_dfr(vars, fit_model) |> arrange(desc(R2))

# present table
results_1 |>
  kable(caption = "Model Performance Metrics", digits = 3) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))



# save plots in order of performance
vars <- results_1$predictor
plots_1 <- map(vars, ~ ggplot(half_hourly_fluxes, aes(x = !!sym(.x), y = GPP_NT_VUT_REF)) +
                 geom_point(alpha = 0.4) +
                 geom_smooth(method = "lm", se = FALSE, color = "red") +
                 labs(x = .x, y = "GPP") +
                 theme_classic())


# display plots
# grid.arrange(grobs = plots_1, ncol = 3, nrow = 5)

```


objective 2:
stepwise

```{r stepwise, message=FALSE, warning=FALSE}

# empty data frame for saving of model performances
stepwise = data.frame(predictor = " ",
                      R2 = 0,
                      AIC = Inf)

for(i in 1:length(vars)){
  
  # get individual predictors so that I can exclude them for future multiple predictor models
  stepwise_split <- unlist(strsplit(stepwise$predictor, " "))
  
  # apply the function to the all possible combinations with the previous BEST PERFOMING MODEL
  results_2 <- map_dfr( paste0(stepwise$predictor[nrow(stepwise)]," + ", setdiff(vars, stepwise_split)),  fit_model)
  
  # extract and save the best performing NEW MODEL from results
  stepwise <- rbind(stepwise, results_2[results_2$AIC == min(results_2$AIC),])
  
  # if the NEW MODEL (the bottom one because rbind) is NOT THE BEST -> STOP
  if(min(stepwise$AIC) != stepwise$AIC[nrow(stepwise)]){
    break
    }

}

# clean up the dataframe
stepwise <- stepwise |>
  slice(2:(n() - 1)) |>
  mutate(predictor = substr(predictor, 5, nchar(predictor))) |>
  mutate(index = seq_along(predictor)) |>
  select(index, everything())

# present table
stepwise |>
  kable(caption = "Stepwise Regression Model Performance Metrics", digits = 5) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))


```







